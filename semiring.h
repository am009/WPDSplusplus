//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2005
//   Nicholas Kidd  <kidd@cs.wisc.edu>
//   Thomas Reps    <reps@cs.wisc.edu>
//   David Melski   <melski@grammatech.com>
//   Akash Lal      <akash@cs.wisc.edu>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
//   1. Redistributions of source code must retain the above copyright
//      notice, this list of conditions and the following disclaimer.
//
//   2. Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in
//      the documentation and/or other materials provided with the
//      distribution.
//
//   3. Neither the name of the University of Wisconsin, Madison,
//      nor GrammaTech, Inc., nor the names of the copyright holders
//      and contributors may be used to endorse or promote
//      products derived from this software without specific prior
//      written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//////////////////////////////////////////////////////////////////////////////

#ifndef SEMIRING_H_
#define SEMIRING_H_ 1

#include "ref_ptr.h"
#include <cstdio>


namespace wpds {

    /*! @class Semiring
     *
     * @brief Templated class for that defines the Weights
     *
     * The elements themselves are responsible for defining what 
     * the actions are.  To be more concise, candidates to be Semiring
     * elements should have all the following methods (with SemiringData being
     * the element's type).
     *
     * This class simply allows for a common interface for WPDS and
     * also does reference counting for the SemiringData * elements.  The user
     * does not need to worry about keeping track of any SemiringData * elements
     * generated by extend/combine b/c they will be garbage collected when
     * the last reference expires.  See ref_ptr.h for requirements (this
     * is basically just the need for a public field of type unsigned int and
     * name count).
     *
     * @see ref_ptr
     *
     */
    template< typename SemiringData > class Semiring {

        public:
            typedef ref_ptr<SemiringData> SemiringElement;

            SemiringData *get_data() {
                return sr_data.get_ptr();
            }

            Semiring( SemiringData *srd, bool forward_=true )
                : sr_data(srd), forward(forward_) {}

            /*! one() is the neutral element of the semiring with
             * respect to the extend operator.
             *
             * @return the semiring element One
             */
            SemiringElement one() const
            {
                return SemiringElement(sr_data->one());
            }

            /*! zero() is the neutral element of the semiring
             * with respect to the combine operator and it is the
             * annihilator with respect to the extend operator
             * 
             * @return the semiring element Zero
             */
            SemiringElement zero() const
            {
                return SemiringElement(sr_data->zero());
            }

            SemiringElement extend( const SemiringElement& se1,
                    const SemiringElement& se2 ) const
            {
                if( forward )
                    return SemiringElement( se1->extend(se2.get_ptr()) );
                else
                    return SemiringElement( se2->extend(se1.get_ptr()) );
            }

            /*
             * The boolean flag "forward" does not matter here b/c a+b = b+a
             */
            SemiringElement combine( const SemiringElement& se1,
                    const SemiringElement& se2 ) const
            {
                return SemiringElement( se1->combine(se2.get_ptr()) );
            }

            /*! Wrapper for SemiringData's quasiOne method.
             *
             * If quasiOne is not needed define it as just returning 
             * the Semiring's One element.  ie.  { return one(); }
             */
            SemiringElement quasiOne( const SemiringElement& se1 ) const
            {
                return SemiringElement( se1->quasiOne() );
            }

            /*! equal compares two semiring elements
             *
             * @return true if the elements are equal
             */
            bool equal( const SemiringElement& se1,
                    const SemiringElement& se2 ) const
            {
                return 0 != se1->equal(se2.get_ptr());
            }

#ifdef DWPDS
            SemiringElement diff( const SemiringElement& se1,
                    const SemiringElement& se2 ) const
            {
                return SemiringElement( se1->diff(se2.get_ptr()) );
            }
#endif // DWPDS

            /*! parse_element calls the templated type T's parse_element
             * method.  This implement rudimentary support for generating
             * a WPDS from an input file.
             *
             * @see WPDS::parse_string
             */
            SemiringElement parse_element( const char *str ) const
            {
                return SemiringElement( sr_data->parse_element( str ) );
            }
            SemiringElement parse_element( const char *str, char * &endpoint ) const
            {
                return SemiringElement( SemiringData::parse_element( str, endpoint ) );
            }
        private:
            SemiringElement sr_data;
            // This is b/c poststar builds such that we must reverse
            // extend to get data out.  Hence, forward is normal and
            // forward "falsified" is reversed.
            bool forward;

    }; // class Semiring

} // namespace wpds

#endif  // SEMIRING_H_
/* Yo, Emacs!
;;; Local Variables: ***
;;; tab-width: 4 ***
;;; End: ***
*/
